// Auto-generated Ring extension
// Generated by parsec.ring
// Do not edit manually

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use ring_lang_rs::*;
use std::ffi::c_void;

use base64::{engine::general_purpose::STANDARD, Engine};
use md5::{Digest as Md5Digest, Md5};
use sha2::{Sha256, Sha512};

/// Encode a string to Base64
pub fn base64_encode(input: &str) -> String {
    STANDARD.encode(input.as_bytes())
}

/// Decode a Base64 string
pub fn base64_decode(input: &str) -> String {
    STANDARD.decode(input).map(|b| String::from_utf8_lossy(&b).to_string()).unwrap_or_default()
}

/// Encode a string to hexadecimal
pub fn hex_encode(input: &str) -> String {
    hex::encode(input.as_bytes())
}

/// Decode a hexadecimal string
pub fn hex_decode(input: &str) -> String {
    hex::decode(input).map(|b| String::from_utf8_lossy(&b).to_string()).unwrap_or_default()
}

/// Compute MD5 hash of a string
pub fn md5_hash(input: &str) -> String {
    let mut hasher = Md5::new();
    hasher.update(input.as_bytes());
    hex::encode(hasher.finalize())
}

/// Compute SHA-256 hash of a string
pub fn sha256_hash(input: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(input.as_bytes());
    hex::encode(hasher.finalize())
}

/// Compute SHA-512 hash of a string
pub fn sha512_hash(input: &str) -> String {
    let mut hasher = Sha512::new();
    hasher.update(input.as_bytes());
    hex::encode(hasher.finalize())
}

#[derive(Default)]
pub struct Hasher {
    pub algorithm: String,
}

impl Hasher {
    pub fn new(algorithm: &str) -> Self {
        Hasher { algorithm: algorithm.to_string() }
    }

    pub fn hash(&self, input: &str) -> String {
        match self.algorithm.as_str() {
            "md5" => { let mut h = Md5::new(); h.update(input.as_bytes()); hex::encode(h.finalize()) }
            "sha256" => { let mut h = Sha256::new(); h.update(input.as_bytes()); hex::encode(h.finalize()) }
            "sha512" => { let mut h = Sha512::new(); h.update(input.as_bytes()); hex::encode(h.finalize()) }
            _ => String::from("unknown algorithm")
        }
    }

    pub fn set_algorithm(&mut self, algorithm: &str) {
        self.algorithm = algorithm.to_string();
    }

    pub fn get_algorithm(&self) -> String {
        self.algorithm.clone()
    }
}

// ============================================
// Function: base64_encode
// ============================================
ring_func!(ring_hash_base64_encode, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = base64_encode(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: base64_decode
// ============================================
ring_func!(ring_hash_base64_decode, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = base64_decode(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: hex_encode
// ============================================
ring_func!(ring_hash_hex_encode, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = hex_encode(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: hex_decode
// ============================================
ring_func!(ring_hash_hex_decode, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = hex_decode(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: md5_hash
// ============================================
ring_func!(ring_hash_md5_hash, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = md5_hash(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: sha256_hash
// ============================================
ring_func!(ring_hash_sha256_hash, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = sha256_hash(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Function: sha512_hash
// ============================================
ring_func!(ring_hash_sha512_hash, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let __result = sha512_hash(__arg_1);
    ring_ret_string!(p, &__result);
});

// ============================================
// Struct: Hasher
// ============================================
const HASHER_TYPE: &[u8] = b"Hasher\0";

// Constructor
ring_func!(ring_hash_hasher_new, |p| {
    ring_check_paracount!(p, 1);
    ring_check_string!(p, 1);

    let __arg_1 = ring_get_string!(p, 1);

    let obj = Box::new(Hasher::new(__arg_1));
    ring_ret_cpointer!(p, Box::into_raw(obj), HASHER_TYPE);
});

// Destructor
ring_func!(ring_hash_hasher_delete, |p| {
    ring_check_paracount!(p, 1);
    ring_check_cpointer!(p, 1);
    let ptr = ring_get_cpointer!(p, 1, HASHER_TYPE);
    if !ptr.is_null() {
        unsafe { let _ = Box::from_raw(ptr as *mut Hasher); }
    }
});


// ============================================
// Impl: Hasher
// ============================================

// Method: hash
ring_func!(ring_hash_hasher_hash, |p| {
    ring_check_paracount!(p, 2);
    ring_check_cpointer!(p, 1);
    ring_check_string!(p, 2);

    if let Some(obj) = ring_get_pointer!(p, 1, Hasher, HASHER_TYPE) {
        let __arg_2 = ring_get_string!(p, 2);

        let __result = obj.hash(__arg_2);
        ring_ret_string!(p, &__result);
    } else {
        ring_error!(p, "Invalid Hasher pointer");
    }
});

// Method: set_algorithm
ring_func!(ring_hash_hasher_set_algorithm, |p| {
    ring_check_paracount!(p, 2);
    ring_check_cpointer!(p, 1);
    ring_check_string!(p, 2);

    if let Some(obj) = ring_get_pointer!(p, 1, Hasher, HASHER_TYPE) {
        let __arg_2 = ring_get_string!(p, 2);

        obj.set_algorithm(__arg_2);
    } else {
        ring_error!(p, "Invalid Hasher pointer");
    }
});

// Method: get_algorithm
ring_func!(ring_hash_hasher_get_algorithm, |p| {
    ring_check_paracount!(p, 1);
    ring_check_cpointer!(p, 1);

    if let Some(obj) = ring_get_pointer!(p, 1, Hasher, HASHER_TYPE) {

        let __result = obj.get_algorithm();
        ring_ret_string!(p, &__result);
    } else {
        ring_error!(p, "Invalid Hasher pointer");
    }
});

// ============================================
// Library Registration
// ============================================
ring_libinit! {
    "hash_base64_encode" => ring_hash_base64_encode,
    "hash_base64_decode" => ring_hash_base64_decode,
    "hash_hex_encode" => ring_hash_hex_encode,
    "hash_hex_decode" => ring_hash_hex_decode,
    "hash_md5_hash" => ring_hash_md5_hash,
    "hash_sha256_hash" => ring_hash_sha256_hash,
    "hash_sha512_hash" => ring_hash_sha512_hash,
    "hash_hasher_new" => ring_hash_hasher_new,
    "hash_hasher_delete" => ring_hash_hasher_delete,
    "hash_hasher_hash" => ring_hash_hasher_hash,
    "hash_hasher_set_algorithm" => ring_hash_hasher_set_algorithm,
    "hash_hasher_get_algorithm" => ring_hash_hasher_get_algorithm
}
